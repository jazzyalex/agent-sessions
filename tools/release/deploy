#!/usr/bin/env bash
set -euo pipefail

# deploy - Unified deployment tool for Agent Sessions
# Consolidates bump, release, verify, and changelog workflows
#
# Canonical runbook: docs/deployment.md

REPO_ROOT=$(cd "$(dirname "$0")/../.." && pwd)
cd "$REPO_ROOT"

# ============================================================================
# SHARED UTILITIES
# ============================================================================

green(){ printf "\033[32m%s\033[0m\n" "$*"; }
yellow(){ printf "\033[33m%s\033[0m\n" "$*"; }
red(){ printf "\033[31m%s\033[0m\n" "$*"; }

# Structured logging
LOG_FILE=""
STATE_FILE="/tmp/deploy-state.json"

init_logging() {
  local context="${1:-deploy}"
  LOG_FILE="/tmp/${context}-$(date +%s).log"
  exec > >(tee -a "$LOG_FILE") 2>&1
}

# State management for resume capability
save_state() {
  local version="$1"
  local step="$2"
  local timestamp=$(date -Iseconds)
  cat > "$STATE_FILE" <<EOF
{
  "version": "$version",
  "last_step": "$step",
  "timestamp": "$timestamp",
  "log_file": "$LOG_FILE"
}
EOF
  log INFO "Saved state: $step"
}

load_state() {
  if [[ ! -f "$STATE_FILE" ]]; then
    echo ""
    return 1
  fi
  cat "$STATE_FILE"
}

clear_state() {
  rm -f "$STATE_FILE"
  log INFO "Cleared deployment state"
}

log() {
  local level="$1"; shift
  echo "[$(date -Iseconds)] [$level] $*"
}

# Comprehensive dependency validation
check_dependencies() {
  local required_cmds=("$@")
  local missing=()

  for cmd in "${required_cmds[@]}"; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
      missing+=("$cmd")
    fi
  done

  if [[ ${#missing[@]} -gt 0 ]]; then
    red "ERROR: Missing required dependencies:"
    for dep in "${missing[@]}"; do
      red "  - $dep"
    done
    exit 2
  fi
}

# Retry function for network operations
retry() {
  local max_attempts=3
  local timeout=5
  local attempt=1
  local exitCode=0

  while [[ $attempt -le $max_attempts ]]; do
    if "$@"; then
      return 0
    else
      exitCode=$?
    fi

    if [[ $attempt -lt $max_attempts ]]; then
      yellow "Attempt $attempt failed (exit $exitCode). Retrying in $timeout seconds..."
      sleep $timeout
    fi
    ((attempt++))
  done

  red "Command failed after $max_attempts attempts"
  return $exitCode
}

# Improved cache wait with timeout
wait_for_cache() {
  local url="$1"
  local expected="$2"
  local max_wait="${3:-120}"
  local interval=3

  log INFO "Waiting for cache propagation: $url"

  for ((i=0; i<max_wait; i+=interval)); do
    if curl -sf "$url" 2>/dev/null | grep -q "$expected"; then
      green "✓ Cache propagated after ${i}s"
      return 0
    fi
    sleep $interval
  done

  red "ERROR: Cache did not propagate after ${max_wait}s"
  return 1
}

# Safe, verified version bump with locking and rollback
safe_version_bump() {
  local pbxproj="$1"
  local curr_build="$2"
  local new_build="$3"
  local curr_marketing="$4"
  local new_marketing="$5"

  local lock_file="${pbxproj}.lock"
  local backup_file="${pbxproj}.backup.$(date +%s)"

  PBXPROJ="$pbxproj" \
  LOCK_FILE="$lock_file" \
  BACKUP_FILE="$backup_file" \
  CURR_BUILD="$curr_build" \
  NEW_BUILD="$new_build" \
  CURR_MARKETING="$curr_marketing" \
  NEW_MARKETING="$new_marketing" \
  python3 <<'PYEOF'
import fcntl, os, shutil, sys, time

pbx = os.environ["PBXPROJ"]
lock_path = os.environ["LOCK_FILE"]
backup = os.environ["BACKUP_FILE"]
curr_build = os.environ["CURR_BUILD"]
new_build = os.environ["NEW_BUILD"]
curr_marketing = os.environ["CURR_MARKETING"]
new_marketing = os.environ["NEW_MARKETING"]

curr_build_token = f"CURRENT_PROJECT_VERSION = {curr_build};"
new_build_token = f"CURRENT_PROJECT_VERSION = {new_build};"
curr_marketing_token = f"MARKETING_VERSION = {curr_marketing};"
new_marketing_token = f"MARKETING_VERSION = {new_marketing};"

start = time.time()
timeout = 10

with open(lock_path, "w") as lock:
    while True:
        try:
            fcntl.flock(lock, fcntl.LOCK_EX | fcntl.LOCK_NB)
            break
        except BlockingIOError:
            if time.time() - start > timeout:
                print(f"ERROR: Could not acquire lock {lock_path} after {timeout}s", file=sys.stderr)
                sys.exit(1)
            time.sleep(0.2)

    if not os.path.exists(pbx):
        print(f"ERROR: {pbx} not found", file=sys.stderr)
        sys.exit(1)

    with open(pbx, "r", encoding="utf-8") as f:
        data = f.read()

    if curr_build_token not in data or curr_marketing_token not in data:
        print("ERROR: Expected version tokens not found in project file", file=sys.stderr)
        sys.exit(1)

    shutil.copyfile(pbx, backup)

    updated = data.replace(curr_build_token, new_build_token)
    updated = updated.replace(curr_marketing_token, new_marketing_token)

    if curr_build_token in updated or curr_marketing_token in updated:
        print("ERROR: Old version tokens still present after update", file=sys.stderr)
        shutil.copyfile(backup, pbx)
        sys.exit(1)

    if updated.count(new_build_token) < 1 or updated.count(new_marketing_token) < 1:
        print("ERROR: New version tokens missing after update", file=sys.stderr)
        shutil.copyfile(backup, pbx)
        sys.exit(1)

    tmp = pbx + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        f.write(updated)
        f.flush()
        os.fsync(f.fileno())

    os.replace(tmp, pbx)

    dir_path = os.path.dirname(pbx) or "."
    dir_fd = os.open(dir_path, os.O_RDONLY)
    try:
        os.fsync(dir_fd)
    finally:
        os.close(dir_fd)

print(f"Backup saved to {backup}")
PYEOF
}

# ============================================================================
# SUBCOMMAND: bump
# ============================================================================

cmd_bump() {
  shift # remove 'bump' from args
  local BUMP_TYPE="${1:-patch}"

  [[ "$BUMP_TYPE" =~ ^(major|minor|patch)$ ]] || {
    red "ERROR: Invalid bump type. Use: major, minor, or patch"
    echo "Usage: tools/release/deploy bump [major|minor|patch]"
    exit 1
  }

  check_dependencies git grep sed awk python3
  init_logging "bump-${BUMP_TYPE}"

  log INFO "Starting version bump: $BUMP_TYPE"
  echo "==> Version Bump: $BUMP_TYPE"

  # Detect current version
  local CURR_MARKETING=$(grep -m1 "MARKETING_VERSION = " AgentSessions.xcodeproj/project.pbxproj | sed 's/.*= \([^;]*\);/\1/' | tr -d ' ')
  local CURR_BUILD=$(grep -m1 "CURRENT_PROJECT_VERSION = " AgentSessions.xcodeproj/project.pbxproj | sed 's/.*= \([^;]*\);/\1/' | tr -d ' ')

  echo "Current version: $CURR_MARKETING (build $CURR_BUILD)"

  # Calculate new version using Python
  local NEW_VERSION=$(python3 << PYEOF
import sys
version = "$CURR_MARKETING".split('.')
major, minor = int(version[0]), int(version[1])
patch = int(version[2]) if len(version) > 2 else 0

if "$BUMP_TYPE" == "major":
    major += 1
    minor = 0
    patch = 0
elif "$BUMP_TYPE" == "minor":
    minor += 1
    patch = 0
elif "$BUMP_TYPE" == "patch":
    patch += 1

print(f"{major}.{minor}.{patch}")
PYEOF
)

  # Auto-increment build number
  local NEW_BUILD=$((CURR_BUILD + 1))

  echo "New version: $NEW_VERSION (build $NEW_BUILD)"

  # Update project.pbxproj
  echo "==> Updating AgentSessions.xcodeproj/project.pbxproj (locked, verified)"
  safe_version_bump "AgentSessions.xcodeproj/project.pbxproj" "$CURR_BUILD" "$NEW_BUILD" "$CURR_MARKETING" "$NEW_VERSION"

  # Verify replacements (read-back)
  local COUNT_BUILD=$(grep -c "CURRENT_PROJECT_VERSION = $NEW_BUILD;" AgentSessions.xcodeproj/project.pbxproj || true)
  local COUNT_VERSION=$(grep -c "MARKETING_VERSION = $NEW_VERSION;" AgentSessions.xcodeproj/project.pbxproj || true)
  local OLD_BUILD_REMAIN=$(grep -c "CURRENT_PROJECT_VERSION = $CURR_BUILD;" AgentSessions.xcodeproj/project.pbxproj || true)
  local OLD_MARKETING_REMAIN=$(grep -c "MARKETING_VERSION = $CURR_MARKETING;" AgentSessions.xcodeproj/project.pbxproj || true)

  if [[ $COUNT_BUILD -lt 1 || $COUNT_VERSION -lt 1 || $OLD_BUILD_REMAIN -gt 0 || $OLD_MARKETING_REMAIN -gt 0 ]]; then
    red "ERROR: Version replacement failed (new build=$COUNT_BUILD new version=$COUNT_VERSION old build still present=$OLD_BUILD_REMAIN old version still present=$OLD_MARKETING_REMAIN)"
    exit 1
  fi
  green "✓ Updated CURRENT_PROJECT_VERSION → $NEW_BUILD and MARKETING_VERSION → $NEW_VERSION"

  # Update CHANGELOG.md
  echo "==> Updating docs/CHANGELOG.md"
  local TODAY=$(date +%Y-%m-%d)

  # Check if version already exists
  if grep -q "^## \[$NEW_VERSION\]" docs/CHANGELOG.md; then
    yellow "WARNING: Version $NEW_VERSION already exists in CHANGELOG.md"
    if [[ "${SKIP_CONFIRM:-0}" != "1" ]]; then
      read -p "Continue anyway? [y/N] " -n 1 -r
      echo
      [[ $REPLY =~ ^[Yy]$ ]] || exit 1
    else
      yellow "SKIP_CONFIRM=1 set, continuing despite existing version in CHANGELOG.md"
    fi
  fi

  # Insert new version section
  awk -v ver="$NEW_VERSION" -v date="$TODAY" '
/^## \[Unreleased\]/ {
    print
    print ""
    print "## [" ver "] - " date
    in_unreleased = 1
    next
}
/^## \[/ && in_unreleased {
    print ""
    print "## [Unreleased]"
    print ""
    in_unreleased = 0
}
{ print }
' docs/CHANGELOG.md > docs/CHANGELOG.md.tmp && mv docs/CHANGELOG.md.tmp docs/CHANGELOG.md

  # Verify CHANGELOG has new section
  if ! grep -q "^## \[$NEW_VERSION\] - $TODAY" docs/CHANGELOG.md; then
    red "ERROR: Failed to update CHANGELOG.md"
    exit 1
  fi
  green "✓ Added [$NEW_VERSION] section to CHANGELOG.md"

  # Show diff for review
  echo ""
  echo "==> Changes to be committed:"
  git diff AgentSessions.xcodeproj/project.pbxproj docs/CHANGELOG.md | head -50

  # Confirm before committing
  echo ""
  if [[ "${SKIP_CONFIRM:-0}" != "1" ]]; then
    read -p "Commit these changes? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      yellow "Aborted. Run 'git checkout AgentSessions.xcodeproj/project.pbxproj docs/CHANGELOG.md' to revert."
      exit 1
    fi
  else
    green "Proceeding automatically (SKIP_CONFIRM=1): committing version bump without interactive prompt"
  fi

  # Git commit
  echo "==> Creating git commit"
  git add AgentSessions.xcodeproj/project.pbxproj docs/CHANGELOG.md

  # Read actual changes from CHANGELOG for commit message
  local CHANGELOG_EXCERPT=$(sed -n "/^## \[$NEW_VERSION\]/,/^## \[/{/^## \[/d; p;}" docs/CHANGELOG.md | head -15)

  git commit -m "chore: bump version to $NEW_VERSION (build $NEW_BUILD)

Build number: $CURR_BUILD → $NEW_BUILD
Marketing version: $CURR_MARKETING → $NEW_VERSION

Release highlights:
$CHANGELOG_EXCERPT

Tool: deploy bump
Model: Sonnet 4.5
Why: Version bump for $NEW_VERSION release"

  green "✓ Version bump committed"
  log INFO "Version bump completed: $CURR_MARKETING → $NEW_VERSION"

  echo ""
  echo "Next steps:"
  echo "  1. Review commit: git show HEAD"
  echo "  2. Push to GitHub: git push origin main"
  echo "  3. Deploy: tools/release/deploy release $NEW_VERSION"
}

# ============================================================================
# SUBCOMMAND: release
# ============================================================================

cmd_release() {
  shift # remove 'release' from args

  # Parse release arguments
  local VERSION=""
  local DRY_RUN=0
  local SKIP_VALIDATION=0

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dry-run)
        DRY_RUN=1
        shift
        ;;
      --skip-validation)
        SKIP_VALIDATION=1
        shift
        ;;
      -*)
        red "ERROR: Unknown option: $1"
        echo "Usage: tools/release/deploy release VERSION [--dry-run] [--skip-validation]"
        exit 1
        ;;
      *)
        VERSION="$1"
        shift
        ;;
    esac
  done

  if [[ -z "$VERSION" ]]; then
    red "ERROR: VERSION not provided"
    echo "Usage: tools/release/deploy release VERSION [--dry-run] [--skip-validation]"
    exit 1
  fi

  check_dependencies xcodebuild git gh python3 curl shasum codesign hdiutil security
  init_logging "release-${VERSION}"

  log INFO "Starting release deployment for version $VERSION"

  # ============================================================================
  # DRY-RUN MODE
  # ============================================================================
  if [[ "$DRY_RUN" -eq 1 ]]; then
    echo ""
    echo "═══════════════════════════════════════════════════════════"
    yellow "  DRY-RUN MODE - No changes will be made"
    echo "═══════════════════════════════════════════════════════════"
    echo ""

    echo "==> Version: $VERSION"
    echo ""

    echo "==> Pre-deployment validation would run..."
    if [[ -x "$REPO_ROOT/tools/release/validate-release.sh" ]]; then
      "$REPO_ROOT/tools/release/validate-release.sh" "$VERSION"
    else
      yellow "    validate-release.sh not found"
    fi

    echo ""
    echo "==> Steps that would be performed:"
    echo "    1. Build Release configuration (xcodebuild)"
    echo "    2. Create signed DMG (create_dmg_from_app)"
    echo "    3. Submit to Apple Notary (xcrun notarytool)"
    echo "    4. Wait for notarization (xcrun notarytool wait)"
    echo "    5. Staple notarization ticket (xcrun stapler)"
    echo "    6. Generate SHA256 checksum"
    echo "    7. Generate appcast.xml (generate_appcast)"
    echo "    8. Update Homebrew cask"
    echo "    9. Create git tag v$VERSION"
    echo "    10. Create GitHub release with DMG"
    echo "    11. Push changes to remote"
    echo ""

    echo "==> Files that would be modified:"
    echo "    - dist/AgentSessions-$VERSION.dmg (created)"
    echo "    - dist/AgentSessions-$VERSION.dmg.sha256 (created)"
    echo "    - docs/appcast.xml (updated)"
    echo "    - homebrew-cask/Casks/agent-sessions.rb (updated)"
    echo ""

    echo "═══════════════════════════════════════════════════════════"
    green "  DRY-RUN complete. Run without --dry-run to deploy."
    echo "═══════════════════════════════════════════════════════════"
    return 0
  fi

  # ============================================================================
  # PRE-DEPLOYMENT VALIDATION
  # ============================================================================
  if [[ "$SKIP_VALIDATION" -eq 1 ]]; then
    echo ""
    yellow "⚠️  SKIP_VALIDATION=1: Skipping pre-deployment validation"
    yellow "   This is not recommended for production releases!"
    echo ""
  else
    echo ""
    echo "==> Running pre-deployment validation..."

    if [[ -x "$REPO_ROOT/tools/release/validate-release.sh" ]]; then
      local VALIDATION_EXIT=0
      "$REPO_ROOT/tools/release/validate-release.sh" "$VERSION" || VALIDATION_EXIT=$?

      if [[ "$VALIDATION_EXIT" -eq 2 ]]; then
        red ""
        red "═══════════════════════════════════════════════════════════"
        red "  VALIDATION FAILED: Cannot proceed with deployment"
        red "  Fix the errors above and retry."
        red "═══════════════════════════════════════════════════════════"
        exit 2
      elif [[ "$VALIDATION_EXIT" -eq 1 ]]; then
        yellow ""
        yellow "═══════════════════════════════════════════════════════════"
        yellow "  VALIDATION PASSED WITH WARNINGS"
        yellow "═══════════════════════════════════════════════════════════"
        echo ""
        if [[ "${SKIP_CONFIRM:-0}" != "1" ]]; then
          read -p "Continue with deployment despite warnings? [y/N] " -n 1 -r
          echo
          if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            yellow "Deployment aborted. Fix warnings and retry."
            exit 1
          fi
        else
          yellow "SKIP_CONFIRM=1: Proceeding despite warnings"
        fi
      else
        green ""
        green "═══════════════════════════════════════════════════════════"
        green "  VALIDATION PASSED: All checks OK"
        green "═══════════════════════════════════════════════════════════"
      fi
    else
      yellow "WARNING: validate-release.sh not found, skipping validation"
    fi
    echo ""
  fi

  # Source the existing deploy-agent-sessions.sh script with VERSION set
  export VERSION="$VERSION"
  export SKIP_CONFIRM="${SKIP_CONFIRM:-0}"

  # Call the existing deployment script
  "$REPO_ROOT/tools/release/deploy-agent-sessions.sh"
}

# ============================================================================
# SUBCOMMAND: verify
# ============================================================================

cmd_verify() {
  shift # remove 'verify' from args
  local VERSION="${1:-}"

  if [[ -z "$VERSION" ]]; then
    red "ERROR: VERSION not provided"
    echo "Usage: tools/release/deploy verify VERSION"
    exit 1
  fi

  check_dependencies git gh curl grep base64

  log INFO "Starting deployment verification for version $VERSION"

  # Call the existing verify-deployment.sh script
  "$REPO_ROOT/tools/release/verify-deployment.sh" "$VERSION"
}

# ============================================================================
# SUBCOMMAND: changelog
# ============================================================================

cmd_changelog() {
  shift # remove 'changelog' from args
  local FROM_TAG="${1:-}"

  check_dependencies git grep sed

  # Auto-detect last tag if not provided
  if [[ -z "$FROM_TAG" ]]; then
    FROM_TAG=$(git tag --sort=-version:refname | grep -E '^v[0-9]' | head -n1)
    if [[ -z "$FROM_TAG" ]]; then
      red "ERROR: No previous tags found and no FROM_TAG specified"
      exit 1
    fi
    yellow "Using last tag: $FROM_TAG"
  fi

  echo "==> Generating CHANGELOG from $FROM_TAG..HEAD"
  echo ""

  # Extract conventional commits
  local FEAT_COMMITS=$(git log --pretty=format:"%s" "$FROM_TAG..HEAD" | grep "^feat:" || true)
  local FIX_COMMITS=$(git log --pretty=format:"%s" "$FROM_TAG..HEAD" | grep "^fix:" || true)
  local PERF_COMMITS=$(git log --pretty=format:"%s" "$FROM_TAG..HEAD" | grep "^perf:" || true)
  local REFACTOR_COMMITS=$(git log --pretty=format:"%s" "$FROM_TAG..HEAD" | grep "^refactor:" || true)
  local DOCS_COMMITS=$(git log --pretty=format:"%s" "$FROM_TAG..HEAD" | grep "^docs:" || true)

  # Count commits by category
  local FEAT_COUNT=$(echo "$FEAT_COMMITS" | grep -c "^" || echo "0")
  local FIX_COUNT=$(echo "$FIX_COMMITS" | grep -c "^" || echo "0")
  local PERF_COUNT=$(echo "$PERF_COMMITS" | grep -c "^" || echo "0")
  local REFACTOR_COUNT=$(echo "$REFACTOR_COMMITS" | grep -c "^" || echo "0")
  local DOCS_COUNT=$(echo "$DOCS_COMMITS" | grep -c "^" || echo "0")

  echo "Commit breakdown:"
  echo "  Features:     $FEAT_COUNT"
  echo "  Fixes:        $FIX_COUNT"
  echo "  Performance:  $PERF_COUNT"
  echo "  Refactoring:  $REFACTOR_COUNT"
  echo "  Docs:         $DOCS_COUNT"
  echo ""

  # Generate CHANGELOG content
  local OUTPUT=""

  if [[ -n "$FEAT_COMMITS" ]]; then
    OUTPUT+="### Added\n"
    while IFS= read -r commit; do
      local MSG=$(echo "$commit" | sed -E 's/^feat(\([^)]+\))?:[[:space:]]*//')
      OUTPUT+="- $MSG\n"
    done <<< "$FEAT_COMMITS"
    OUTPUT+="\n"
  fi

  if [[ -n "$FIX_COMMITS" ]]; then
    OUTPUT+="### Fixed\n"
    while IFS= read -r commit; do
      local MSG=$(echo "$commit" | sed -E 's/^fix(\([^)]+\))?:[[:space:]]*//')
      OUTPUT+="- $MSG\n"
    done <<< "$FIX_COMMITS"
    OUTPUT+="\n"
  fi

  if [[ -n "$PERF_COMMITS" ]]; then
    OUTPUT+="### Performance\n"
    while IFS= read -r commit; do
      local MSG=$(echo "$commit" | sed -E 's/^perf(\([^)]+\))?:[[:space:]]*//')
      OUTPUT+="- $MSG\n"
    done <<< "$PERF_COMMITS"
    OUTPUT+="\n"
  fi

  if [[ -n "$REFACTOR_COMMITS" ]]; then
    OUTPUT+="### Refactoring\n"
    while IFS= read -r commit; do
      local MSG=$(echo "$commit" | sed -E 's/^refactor(\([^)]+\))?:[[:space:]]*//')
      OUTPUT+="- $MSG\n"
    done <<< "$REFACTOR_COMMITS"
    OUTPUT+="\n"
  fi

  if [[ -n "$DOCS_COMMITS" ]]; then
    OUTPUT+="### Documentation\n"
    while IFS= read -r commit; do
      local MSG=$(echo "$commit" | sed -E 's/^docs(\([^)]+\))?:[[:space:]]*//')
      OUTPUT+="- $MSG\n"
    done <<< "$DOCS_COMMITS"
    OUTPUT+="\n"
  fi

  if [[ -z "$OUTPUT" ]]; then
    yellow "No conventional commits found. Showing all commits instead:"
    echo ""
    git log --pretty='- %s' "$FROM_TAG..HEAD"
    exit 0
  fi

  green "==> Generated CHANGELOG:"
  echo ""
  echo -e "$OUTPUT"

  # Offer to save to file
  echo ""
  read -p "Save to CHANGELOG snippet file? [y/N] " -n 1 -r
  echo
  if [[ $REPLY =~ ^[Yy]$ ]]; then
    local SNIPPET_FILE="/tmp/changelog-snippet-$(date +%s).md"
    echo -e "$OUTPUT" > "$SNIPPET_FILE"
    green "✓ Saved to $SNIPPET_FILE"
    echo ""
    echo "You can now copy this content into docs/CHANGELOG.md under the [Unreleased] section"
  fi
}

# ============================================================================
# SUBCOMMAND: resume
# ============================================================================

cmd_resume() {
  shift # remove 'resume' from args

  check_dependencies git gh python3

  # Load saved state
  if ! state_json=$(load_state); then
    red "ERROR: No deployment state found"
    echo "Nothing to resume. Use 'tools/release/deploy release VERSION' to start a new deployment."
    exit 1
  fi

  local version=$(echo "$state_json" | python3 -c 'import json,sys; print(json.load(sys.stdin).get("version",""))')
  local last_step=$(echo "$state_json" | python3 -c 'import json,sys; print(json.load(sys.stdin).get("last_step",""))')
  local saved_log=$(echo "$state_json" | python3 -c 'import json,sys; print(json.load(sys.stdin).get("log_file",""))')

  if [[ -z "$version" ]] || [[ -z "$last_step" ]]; then
    red "ERROR: Invalid state file"
    exit 1
  fi

  echo "═══════════════════════════════════════════════════════════"
  echo "  Resuming deployment for version $version"
  echo "  Last completed step: $last_step"
  if [[ -f "$saved_log" ]]; then
    echo "  Previous log: $saved_log"
  fi
  echo "═══════════════════════════════════════════════════════════"
  echo ""

  # Determine next steps based on last completed step
  case "$last_step" in
    "notarization_submitted")
      green "==> Checking notarization status..."
      # Continue with deployment script - it will handle waiting/stapling
      export VERSION="$version"
      export SKIP_CONFIRM="${SKIP_CONFIRM:-1}"
      export RESUME_FROM="notarization"
      "$REPO_ROOT/tools/release/deploy-agent-sessions.sh"
      ;;

    "build_complete")
      green "==> Continuing with appcast generation..."
      export VERSION="$version"
      export SKIP_CONFIRM="${SKIP_CONFIRM:-1}"
      export RESUME_FROM="appcast"
      "$REPO_ROOT/tools/release/deploy-agent-sessions.sh"
      ;;

    "appcast_generated")
      green "==> Continuing with GitHub release..."
      export VERSION="$version"
      export SKIP_CONFIRM="${SKIP_CONFIRM:-1}"
      export RESUME_FROM="github_release"
      "$REPO_ROOT/tools/release/deploy-agent-sessions.sh"
      ;;

    "github_release_created")
      green "==> GitHub release already created, running verification..."
      export VERSION="$version"
      export SKIP_CONFIRM="${SKIP_CONFIRM:-1}"
      if [[ -x "$REPO_ROOT/tools/release/verify-deployment.sh" ]]; then
        "$REPO_ROOT/tools/release/verify-deployment.sh" "$version"
      else
        yellow "WARNING: verify-deployment.sh not found"
      fi
      ;;

    *)
      yellow "Unknown step: $last_step"
      echo "Attempting to continue full deployment..."
      export VERSION="$version"
      export SKIP_CONFIRM="${SKIP_CONFIRM:-1}"
      "$REPO_ROOT/tools/release/deploy-agent-sessions.sh"
      ;;
  esac

  clear_state
  green "Resume complete!"
}

# ============================================================================
# HELP
# ============================================================================

cmd_help() {
  cat << 'EOF'
deploy - Unified deployment tool for Agent Sessions

USAGE:
    tools/release/deploy <subcommand> [options]

SUBCOMMANDS:
    bump [major|minor|patch]    Bump version and update CHANGELOG
                                Default: patch

    release VERSION [OPTIONS]   Build, sign, notarize, and publish release
                                Runs full deployment pipeline

                                Options:
                                  --dry-run         Show what would happen without executing
                                  --skip-validation Skip pre-deployment validation (not recommended)

    verify VERSION              Verify deployment completed successfully
                                Checks GitHub release, appcast, Homebrew cask

    changelog [FROM_TAG]        Generate CHANGELOG from conventional commits
                                Auto-detects last tag if not specified

    resume                      Resume failed deployment from last checkpoint
                                Automatically continues from where it left off

DOCUMENTATION:
    See docs/deployment.md for prerequisites, environment variables, logs, and troubleshooting.

EOF
}

# ============================================================================
# MAIN DISPATCHER
# ============================================================================

SUBCOMMAND="${1:-help}"

case "$SUBCOMMAND" in
  bump)
    cmd_bump "$@"
    ;;
  release)
    cmd_release "$@"
    ;;
  verify)
    cmd_verify "$@"
    ;;
  changelog)
    cmd_changelog "$@"
    ;;
  resume)
    cmd_resume "$@"
    ;;
  help|--help|-h)
    cmd_help
    ;;
  *)
    red "ERROR: Unknown subcommand: $SUBCOMMAND"
    echo ""
    cmd_help
    exit 1
    ;;
esac
